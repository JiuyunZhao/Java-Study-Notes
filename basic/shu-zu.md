数组也是一种引用类型，其父类是Object，使用“数据类型\[\]”声明，如“int\[\] array”表示声明了一个元素类型为int类型的数组array。

**数组初始化语法：**

```java
// 静态初始化语法，即定义的时候就初始化好了所有的元素
int[] array1 = {100, 55, 30};
// 动态初始化语法，初始化时只定义好数组中元素的个数，new int[5]表示创建一个
// 有5个int类型元素的数组，但是并没有初始化数组中元素的值，只是赋予了默认值，即
// 基本数据类型的默认值和引用类型的默认值null。
int[] array2 = new int[5];
```

**使用数组时，应注意以下几点：**

* 数组是一种容器，数组当中可以存储基本数据类型的数据，也可以存储引用数据类型的数据。对于基本数据类型，数组中存储的是数据的值，而引用类型，数组当中存储的是对象的引用，即内存地址。
* 数组因为是引用类型，所以数组对象是存储在堆内存当中的。
* 数组一旦创建，其长度是不可变的。
* 数组中的元素的数据类型是统一的，如int数组则表示此数组中的元素全部都是int类型的。
* 所有数组对象都有length属性（注意不是length方法），用来获取数组中元素的个数。
* 数组中在存储时，数组中的元素的内存地址都是连续的。
* 数组对象的内存地址是数组中第一个元素所在的内存地址。
* 使用下标访问数组时，如果下标超出了数组的长度，则会发生ArrayIndexOutOfBoundsException异常。

**数组的访问和赋值：**直接通过下标进行访问和赋值即可，如“array1\[0\]=22;”。

**数组的优点和缺点：**

* **优点：**根据下标去检索元素时效率极高，因为数组中的元素在空间地址上是连续的，并且每个元素占用的内存空间是相同的，检索某个元素时只需要根据数组内存地址的起始位置就可以算出这个元素的内存地址，所以检索第100个元素和第100万个元素的地址的时间都是一样的。

* **缺点：**一个是，为了保证数组中每个元素的内存地址连续性，所以在数组中间的某个位置删除或增加元素时，会涉及到元素的向前或者向后位移的操作，此时的效率就会极低。另外一个是，数组不能存储大数据量，因为很难在内存空间上找到一块特别大的连续的内存空间。

**数组扩容：**Java中数组扩容的原理或者说方法是将小容量的数组使用“System.arraycopy”方法拷贝到大容量的数组当中，然后删除小容量的数组，Java中数组的扩容效率是较低的，所以在数组的使用当中，应该尽量避免数组的拷贝和扩容。

**二维数组：**二维数组，包括三位数组等多位数组，其实就是数组中的元素又是一个数组，多少维其实由这个数组的元素“套了多少层”决定的，二维就是数组中的元素是一个一维数组，同理，三位数组中的元素是一个二维数组，然后以此类推即可。

```java
// 静态初始化语法
int[][] a = {
    {1, 2, 3},
    {4, 5, 6},
    {9}
};

// 动态初始化语法
int[][] array = new int[3][4];
```

**Arrays工具类：**这个工具类最常用的就是sort和binarySearch这两个方法，但是注意，二分查找方法的前提是数组已经排好序了。

```java
import java.util.Arrays;


public class ArrayToolsTest{
    public static void main(String[] args){
        int[] myArray = {3, 2, 6, 4};
        // sort方法可以将一个数组排序，但是注意，sort方法并没有返回值，
        // 即不是返回排好序的数组，而是直接排序传入的数组
        Arrays.sort(myArray);

        // 二分查找算法的前提是需要数组已经排好序了
        // 返回值为元素在数组中的下标，元素在数组中不存在则返回-1
        // 但是这个方法多用来判断数组中有没有这个元素，因为如果数组中该元素
        // 不只一个的话，那么返回的下标不一定是第一个元素的下标
        int indexd = Arrays.binarySearch(myArray, 6);
    }
}
```



