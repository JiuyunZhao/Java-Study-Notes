### 1、封装和类定义

类主要描述的对象的状态（属性）和动作（方法）。

类也是面向对象编程中“封装”特性在语法上的体现，封装特性的优点通常有以下几点：

* 将程序的实现原理的复杂性进行封装，只对外提供简单的操作入口。
* 封装之后才能形成真正的“对象”和“独立体”的概念。
* 封装意味着程序可以重复使用。
* 封装之后，对于对象本身，提高了安全性。

**一个普通的类的定义语法如下：**

```java
[修饰符列表] class 类名{
    属性;
    方法;
}
```

**成员变量：**在类体之中、方法之外的变量称之为成员变量。成员变量如果没有手动赋值的话，系统会自动赋予默认值（一切向“0”看齐）。成员变量又分为：

* **实例变量（没有static修饰符）  **
* **静态变量（有static修饰符）  **

**注意：**类也是一种数据类型，属于引用数据类型，它的类型名称就是对应的类名。

### 2、对象创建和内存分配

对象就是类实例化之后的具体个体，类到对象的过程称之为实例化，反过来，对象到类的过程则称之为抽象。

**new关键字：**Java中使用new关键字来创建一个对象，new关键字也是Java中的一个运算符。

**内存分配：**当在方法区内存中的代码执行时，会在栈内存中开辟一块该方法对应的内存空间，而在方法执行过程中使用new关键字创建一个对象时，则会在堆内存中开辟一块该对象对应的内存空间。所以方法中定义的局部变量是在栈中的，而创建的对象则是在堆内存中的。实例对象每一个对象都会有自己的一块内存空间，即100个对象就会分配100个内存空间。

**指针屏蔽：**Java中想要访问堆内存中的数据，必须通过引用，而不能直接操作堆内存，因为Java中屏蔽了指针的概念，不能通过指针的方式直接访问或操作内存中的数据。

**访问属性：**对于实例变量属性的读取和修改，使用语法格式“引用.变量名”进行读取，使用语法格式“引用.变量名=值”对属性进行修改。注意，实例变量存储在堆内存中对应的实例对象内部，且不能通过类名的方式来访问。

### 3、空指针异常NullPointerException

当一个引用类型的变量的值不再是指向某个对象的内存地址，而是null，此时再去访问对象的相关属性或方法就会发生空指针异常，因为此时的变量不再指向该对象，而是值为null了，无法去访问该对象了，更不要说访问对象中的属性和方法了，空引用访问实例相关数据就一定会出现空指针异常。

### 4、get方法和set方法

**属性私有化：**在封装特性中，类中的所有属性都应该使用private修饰符进行修饰，private表示私有的，表示此属性只有在本类中才能访问，在类的外部不能访问。但是在类中应该为外部访问这些属性提供一些简单的公开的（public）操作入口，如对应的get方法和set方法。

**get方法和set方法的写法如下：**

```java
// get方法
public 返回值类型 get+属性名首字母大写(){
    return 属性名;
}

// set方法
// 注意，形参的名字如果和属性名相同了，那么属性名前面应该加一个this关键字
// 因为不加this关键字的话，由于名称是相同的，Java的就近原则会认为它俩都是同一个局部变量，即形参
public void set+属性名首字母大写(形参列表){
    属性名=形参值;
    ...
}
```

**注意：**get和set方法是没有static修饰符的，使用的是public修饰符，没有static修饰符的方法的访问方式为“引用.方法名\(实参\)”。

### 5、引用参数的传递

对象变量通常也称之为引用，因为在栈中这个变量只是个局部变量，而对象变量的值是该对象在堆内存中的内存地址，当然，这个内存地址则指向堆内存中的该对象实例。所以对于基本数据类型，值的传递不会影响到原本变量的值，但是对于类的实例，因为传递的值是内存地址，所以它虽然不会影响原本局部变量的值（即内存地址），但是如果对内存地址中的对象实例进行修改则会影响到内存地址指向的实例对象，即原本的局部变量指向的实例对象会被修改。

### 6、构造方法（constructor）

**语法如下：**

```java
 // 构造方法，也称为构造器（constructor）。
 // 构造方法是不用也不能指定返回值类型的。
 // 注意，构造方法名必须和类名相同，所以这里的语法就直接写类名了。
 [修饰符列表] 类名(形式参数列表){
     构造方法体;
 }
```

**构造方法的调用：**构造方法的作用是通过调用构造方法来创建对象并初始化实例变量的值，而构造方法的调用使用new关键字“new 构造方法名\(实参列表\)”，注意new之后调用的其实是构造方法名而不是类名，但因为两者是相同的，所以可能会让人误以为调用的是类名。

**构造方法返回值：**虽然没有指定返回值类型，但是构造方法的返回值类型就是其所在类的类型，返回值就是新创建的对象的引用，但是注意的是这个返回值是不需要开发人员手动编写的，即构造方法的定义中，返回值类型和返回值都不需要人为的去定义。

**默认构造方法：**当类中没有定义构造方法时，系统会给该类提供一个无参数的默认构造器。需要特别注意的是，如果类中提供了构造方法，那么系统就不再为这个类提供默认的无参数构造方法了，所以，如果在类中提供了自己的构造方法，那么推荐手动将无参的构造方法加上，因为这个构造方法太常用了。

关于构造方法，还应该注意以下几点：

* **构造方法支持重载机制。  **
* 因为实例变量是属于实例的，所以**构造方法是先创建对象再初始化实例变量。  **

### 7、this关键字

其实每一个实例对象中都有一个this变量，this中保存的是自身所在实例对象的内存地址，即this是指向实例对象本身的一个引用类型的变量。可以换一种方式理解，this可以出现在实例方法中，而方法中的this代表当前正在执行这个方法动作的实例对象。

在实例方法中对实例变量的访问，由于它是实例变量，所以不使用this关键字也是可以访问的，所以this在多数情况下是可以不写的。this主要用于区分实例变量和局部变量，比如setter方法和构造方法中就比较常用。

当然，this不能在含有static修饰符的方法中使用。

this关键字除了使用“this.xxx”的方式表示实例对象的使用之外，还可以在构造方法中以“this\(实参列表\)”形式表示调用另一个构造方法，但是注意，使用这种用法时这个语句只能出现在构造方法的第一行（当然这个语句之后可以添加其他的语句，但前面就不能有其他任何语句了），如：

```java
 public class User{
     private int age;
     public User(int age){
         this.age = age;
     }
     public User(){
         // 此处表示调用另一个构造方法
         // 但是注意，这个语句只能是此构造方法的第一个语句
         this(18);
         // 之后可以加别的语句
         System.out.println("my age is " + this.age);
     }
 }
```

### 8、继承

**继承特性优点：**继承最基本的作用是代码复用，但是最重要的作用却是有了继承才有了方法的覆盖和多态机制。

**单继承：**Java中的继承机制只支持单继承，一个类不能同时继承多个类，只能继承一个类。语法如下：

```java
// 继承使用extends关键字
  [修饰符列表] class 类名 extends 父类名{
      类体;
  }
```

可以继承的数据：

* private私有的不支持继承。
* 构造方法不支持继承。
* 其他数据可以被继承。

**多继承：**Java中虽然只支持单继承，但是可以间接实现多继承：

```java
  C extends B{
  }
  B extends A{
  }
  A extends T{
  }
  // 这样C直接继承B，但间接继承了T和A类
```

**默认基类：**Java中一个类如果没有显式继承任何类，那么该类默认继承javaSE库中提供的java.lang.Object类。

需要注意一个概念，当一个子类在继承某个父类时，在运行时，不是说在子类中查找对应方法或属性，子类中没有再到父类中查找，而是在定义时，如果继承了某个父类，那么这个类的定义中就包含了父类继承过来的某些方法和属性，即子类对象执行的方法和属性总是自己的属性和方法。

### 9、方法的覆盖/重写（override）

方法的覆盖也称为方法的重写，子类将父类继承过来的方法进行重新编写被称为方法的重写，方法重写时需要注意：

* 方法重写发生在具有继承关系的父子类之间，且是可以继承的方法上（私有的以及构造方法不能继承，也就不能进行重写了）。
* 重写时必须遵守：返回值类型相同，方法名相同，形参列表相同。
* 访问权限不能更低，但是可以更高，private最低，public最高。
* 抛出异常不能更多，但是可以更少。
* 静态方法不存在重写。
* 覆盖只谈方法，不谈属性。

### 10、多态

**向上转型（upcasting）：**子类型 --&gt; 父类型，可以理解为自动类型转换。

**向下转型（downcasting）：**父类型 --&gt; 子类型，可以理解为强制类型转换。

无论是向上转型还是向下转型，都必须具有继承关系，不然编译不通过。

**多态语法机制：**父类型的引用指向子类型对象这种机制导致程序在编译阶段和运行阶段出现了两种不同的形态或状态，这种机制可以称为一种多态语法机制。

**多态的作用：**降低程序的耦合度，提高程序的扩展力。能使用多态就多使用多态，即父类型引用指向子类型对象。

**多态的核心思想：**面向抽象编程，尽量不要面向具体编程。

**示例：**重点在注释哦

```java
public class Animal{
       public void run(){
           System.out.println("动物在移动！");
       }
   }
   
   public class Cat extends Animal{
       public void run(){
           System.out.println("猫在散步！");
       }
       
       public void catchMouse(){
           System.out.println("猫在抓老鼠！");
       }
   }
   
  public class Bird extends Animal{
      public void run(){
           System.out.println("鸟儿在飞翔！");
       }
  }
  
   public class Test{
       public static void main(String[] args){
           // 此处为向上转型，从Cat类型自动转换为Animal类型
           Animal cat1 = new Cat();
           // 向上转型之后，可以访问父类型中的方法，但是如果这个方法被子类型中重写了
           // 那么执行的就是子类型中的方法了，并且类型转化之后不能再执行子类型中特有的方法了
           // 比如catchMouse方法，但是需要注意的是，虽然类型转换了，但是引用指向的堆内存中的
           // 对象依然是最开始创建的Cat类型的源对象cat1，所以执行方法时原则就是子类型中没有就执行继承自父类型的方法，如果子类型中有这个方法时就执行子类型中的方法，但是不能执行子类型中特有的方法。
           // 在编译阶段会将符合语法的该对象的方法绑定，这个过程称之为静态绑定，只有静态绑定成功之后才能运行程序。这个例子中，静态绑定是将Animal的move方法绑定到cat1对象，因为cat1是声明为Animal类型的，而Animal类是有move方法的，所以能绑定成功。
           // 在运行阶段则会将实际运行的方法绑定到该对象上，这个过程称之为动态绑定，这个例子中，动态绑定是，在运行时，由于是先在内存中生成的对象是new出来的Cat类型的对象，虽然在等号赋值运算时类型被转换为Animal类型了，但是内存中其实还是那个被创建好的Cat类型的cat1对象，所以会执行Cat类中的move方法。
           cat1.run();  // 输出为：猫在散步！
           
           // 此处会编译不通过，虽然cat对象有catchMouse方法，但是类型转换后，因为Animal类型中没有catchMouse方法，所以编译不通过，即静态绑定失败。当然，也就不可能继续运行了。
           cat1.catchMouse();
           
           // 向下转型，这里不仅能编译通过，还能正确执行catchMouse方法，因为cat1其本质就是最初在内存中创建的Cat类型对象，而Cat类是由这个方法的
           Cat cat2 = (Cat)cat1;
           cat2.catchMouse();
           
           // 此处的向下转型编译能能通过，但是运行会报错java.lang.ClassCastException（除了空指针异常之外另一个著名的异常），即类型转换异常，而且只有在向下转型的时候会发生。
           // 因为第一个语句向上转型后，其实际还是个Bird类型对象，在第二个语句的向下转型，因为
           // Animal类型和Cat类型之间具有继承关系，所以可以编译通过，但是运行时由于它本质是Bird类型
           // 对象，不能转换成Cat类型对象，因为Bird和Cat之间没有继承关系，所以会报错。
           Animal bird1 = new Bird();
           Cat cat3 = (Cat)bird1;
       }
   }
```

### 11、instanceof运算符

**语法：**“引用 instanceof 数据类型名”，返回值为true/false，true表示这个引用指向的内存真实对象就是该数据类型的对象，false则表示这个引用指向的内存真实对象不是该数据类型的对象。如上例中“Animal bird1 = new Bird\(\);”的bird1虽然转换成了Animal类型，但其真实内存对象其实是Bird类型的，所以如果执行“bird1 isinstanceof Bird”就会返回true。

Java编程规范中，在进行强制类型转换时，建议先使用instanceof运算符判断引用的类型再进行转换。



